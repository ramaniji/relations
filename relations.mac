/**************************************************************************************************************************************
 
 			
 			
 			relations.mac 
 			 
 			 
 			 
 
**************************************************************************************************************************************/
 
 
 
 
/**************************************************************************************************************************************


 
 			COPYRIGHT NOTICE


    
    
    
Copyright (C) 2025 J V Ramani  


The examples are from the book by :

1.  Kenneth Rosen :: Discrete Mathematics and Its Applications
  
        
        

    
    
This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or 
(at your option) any later version. 

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of 
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
See the GNU General Public License  for more details at
http://www.gnu.org/copyleft/gpl.html


For comments, suggestions and the like, feel free to contact the author at

		ramaniji AT yahoo DOT com
    
    
    
    
    
**************************************************************************************************************************************/







/**************************************************************************************************************************************



How to load this package


   
(%i1) load(relations);



**************************************************************************************************************************************/





/**************************************************************************************************************************************






 relations.mac is a package of Maxima functions for relations and partial orders:
 
 
 1.  findRelation(A1)
 
 2.  checkReflexive(A1,   R1);
 
 3.  checkSymmetric(A1,  R1)
 
 4.  checkAntiSymmetric(A1,  R1)
 
 5.  checkTransitive(A1,   R1);
 
 6.  findCoveringRelation(A1,  R1);
 
 7.  maximalElements(A1,   R1);
 
 8.  minimalElements(A1,   R1);
 
 9.  gElement(A1,  R1);
 
 10. sElement(A1,  R1);
 
 11. findUpperBounds(A1,   R1,   P1);
 
 12. findLowerBounds(A1,   R1,   P1);
 
 13. lub(A1,   R1,   P1);
 
 14. glb(A1,   R1,   P1);
 
 15. checkLattice(A1,  R1);
 
 
 
 
 
**************************************************************************************************************************************/









/**************************************************************************************************************************************





findRelation([1,  2,  3,   4]);



findRelation(A1);






**************************************************************************************************************************************/


findRelation(A):=block
(
	[A2:cartesian_product_list(A,  A),  R:[]],
	for i:1 thru length(A2) do
	(
		t:A2[i],
	    	if(remainder(t[2],   t[1])=0) then R:cons(t,  R)
	    	),
	    	R
);
	





/**************************************************************************************************************************************





checkReflexive(A1,   R1);






**************************************************************************************************************************************/



checkReflexive(A,  R):=block
(
 	[s:0],
   	for i:1 thru length(A) do
   	(
        	if(member([A[i],  A[i]],   R) = true) then (s:s+1)
   	),
   	if(s=length(A)) then return("reflexive") else return("Not reflexive")       
);





/**************************************************************************************************************************************





checkSymmetric(A1,  R1)






**************************************************************************************************************************************/



checkSymmetric(A,  R):=block
(
	[s:0,  t],
   	for i:1 thru length(R) do
   	(
        	t:R[i],
        	if(member([t[2],  t[1]],   R)) then (s:s+1)
        ),
   	if(s=length(R)) then return("symmetric") else return("Not symmetric")       
);




/**************************************************************************************************************************************





checkAntiSymmetric(A1,  R1)






**************************************************************************************************************************************/



checkAntiSymmetric(A,   R):=block
(
    	[s:0,  t],
   	for i:1 thru length(R) do
   	(
        	t:R[i],
        	if( is(t[1]#t[2])) then(if(member([t[1],   t[2]],  R) and member([t[2],  t[1]],   R)) then(s:s+1)) 
        ),
   	if(s=0) then return("Anti symmetric") else return("Not Anti symmetric")
);




/**************************************************************************************************************************************





checkTransitive(A1,   R1);






**************************************************************************************************************************************/




checkTransitive(A,  R):=block
(
   	[s:0,  t],
   	for i:1 thru length(A) do
   	(
        	for j:1 thru length(A) do
        	(
            		for k:1 thru length(A) do
            		(
                		if(member([A[i],  A[j]],  R) and member([A[j],  A[k]],   R)) then(if(member([A[i],  A[k]],   R )) then(s:0) else(s:1, return(s)))
            		),
            		if(s=1) then(return(s))
        	),
        	if(s=1) then(return(s)) 
    	),
    	if(s=1) then(return("not transitive")) else(return("transitive"))           
);



/**************************************************************************************************************************************





findCoveringRelation(A1,  R1);






**************************************************************************************************************************************/



findCoveringRelation(A,  R):=block
(
	[C:[],   nR:[],   s,   e,   f],
    	for k:1 thru length(R) do
    	(
         	if(R[k][1]#R[k][2]) then(nR:cons([R[k][1],   R[k][2]],   nR))
    	),
    	for j:1 thru length(nR) do
    	(
        	e:nR[j][1],
        	f:nR[j][2],
        	s:0,
        	for i:1 thru length(A) do
        	(
            		if(member([e,  A[i]],   nR) and member([A[i],  f],   nR)) then(s:s+1) 
        	),
        	if(s=0) then(C:cons([e,   f],   C))
    	),
    	return(C)
);



/**************************************************************************************************************************************





maximalElements(A1,   R1);






**************************************************************************************************************************************/




maximalElements(A,   R):=block
(
    	[s,  C:[]],
    	for k:1 thru length(A) do
    	(
        	s:0,
        	for i:1 thru length(A) do
        	(
            		if((k#i) and (member([A[k],   A[i]],   R))) then(s:s+1)
        	),
        	if(s=0) then(C:cons(A[k],   C))
    	),
    	return(C)
);





/**************************************************************************************************************************************





minimalElements(A1,   R1);






**************************************************************************************************************************************/



minimalElements(A,   R):=block
(
    	[s,  C:[]],
    	for k:1 thru length(A) do
    	(
        	s:0,
        	for i:1 thru length(A) do
        	(
            		if((k#i) and (member([A[i],   A[k]],   R))) then(s:s+1)
        	),
        	if(s=0) then(C:cons(A[k],   C))
    	),
    	return(C)
);



/**************************************************************************************************************************************





gElement(A1,  R1);






**************************************************************************************************************************************/




gElement(A,   R):=block
(
    	[s,  f:0,   t:0],
    	for j:1 thru length(A) do
    	(
        	s:0,
        	for i:1 thru length(A) do
        	(
            		if(member([A[i],   A[j]],   R)) then(s:s+1)
        	),
        	if(s=length(A)) then(t:j, return(t)) 
    	),
    	if(t=0) then(return("no greatest element")) else(return(concat(A[t],  " is the greatest element"))) 
);




/**************************************************************************************************************************************





sElement(A1,  R1);






**************************************************************************************************************************************/



sElement(A,   R):=block
(
    	[s,  f:0,   t:0],
    	for i:1 thru length(A) do
    	(
        	s:0,
        	for j:1 thru length(A) do
        	(
            		if(member([A[i],   A[j]],   R)) then(s:s+1)
        	),
        	if(s=length(A)) then(t:i, return(t))
    	),
    	if(t=0) then(return("no least element")) else(return(concat(A[t],  " is the least element"))) 
        
);



/**************************************************************************************************************************************





findUpperBounds(A1,   R1,   P1);






**************************************************************************************************************************************/



findUpperBounds(A,   R,   P):=block
(
	[s,   t,   C:[]],
    	for k:1 thru length(A) do
    	(
        	s:0,
        	t:A[k],
        	for i:1 thru length(P) do
        	(
        		if(member([P[i],   t],    R)) then(s:s+1)
        	),
        	if(s=length(P)) then(C:cons(t,   C)) 
    	),
    	return(C)
);


/**************************************************************************************************************************************





findLowerBounds(A1,   R1,   P1);






**************************************************************************************************************************************/




findLowerBounds(A,   R,   P):=block
(
    	[s,   t,   C:[]],
    	for k:1 thru length(A) do
    	(
        	s:0,
        	t:A[k],
        	for i:1 thru length(P) do
        	(
        		if(member([t,   P[i]],    R)) then(s:s+1)
        	),
        	if(s=length(P)) then(C:cons(t,   C)) 
    	),
    	return(C)
);


/**************************************************************************************************************************************





lub(A1,   R1,   P1);






**************************************************************************************************************************************/



lub(A,   R,   P):=block
(
    	[U:findUpperBounds(A,  R,  P)],
    	if(U=[]) then(return(U)) else
    	(
        	t:U[1],
        	for i:2 thru length(U) do
        	(
            		if(member([U[i],   t],   R)) then(t:U[i])
        	),
        	return(t)
    	)
);




/**************************************************************************************************************************************





glb(A1,   R1,   P1);






**************************************************************************************************************************************/



glb(A,   R,   P):=block
(
    	[L:findLowerBounds(A,  R,  P)],
    	if(L=[]) then(return(L)) else
    	(
        	t:L[1],
        	for i:2 thru length(L) do
        	(
            		if(member([t,   L[i]],   R)) then(t:L[i])
        	),
        	return(t)
    	)
);






/**************************************************************************************************************************************





checkLattice(A1,  R1);






**************************************************************************************************************************************/




checkLattice(A,   R):=block
(
    	[s:0],
    	for i:1 thru length(A) do
    	(
        	for j:1 thru length(A) do
        	(
            		if( (lub(A,   R,   [A[i],   A[j]])#[]) and (glb(A,   R,   [A[i],   A[j]])#[])) then(s:s+1)
        	)
    	),
    	if(s=(length(A))^2) then(return("lattice")) else(return("not a lattice"))
);










